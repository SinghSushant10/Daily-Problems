#3362. Zero Array Transformation III

class Solution {
    public int maxRemoval(int[] nums, int[][] queries) {
        int n = nums.length;
        int m = queries.length;
        int[] diff = new int[n + 1]; // Difference array for range updates

        // Step 1: Apply all queries to the difference array
        for (int[] query : queries) {
            int li = query[0];
            int ri = query[1];
            diff[li] += 1;
            if (ri + 1 < n) diff[ri + 1] -= 1;
        }

        // Step 2: Compute the total effect on nums
        int[] effects = new int[n];
        int currentEffect = 0;
        for (int i = 0; i < n; i++) {
            currentEffect += diff[i];
            effects[i] = currentEffect;
        }

        // Step 3: Check if nums can be zeroed with all queries
        if (!canBeZeroed(nums, effects)) {
            return -1; // If not possible, return -1
        }

        // Step 4: Try to remove queries while maintaining feasibility
        int removed = 0;
        for (int i = 0; i < m; i++) {
            int li = queries[i][0];
            int ri = queries[i][1];

            // Temporarily remove the query's effect
            for (int j = li; j <= ri; j++) {
                effects[j] -= 1;
            }

            // Check if nums can still be zeroed
            if (canBeZeroed(nums, effects)) {
                removed++; // Successfully removed the query
            } else {
                // Revert the query's effect if nums cannot be zeroed
                for (int j = li; j <= ri; j++) {
                    effects[j] += 1;
                }
            }
        }

        return removed;
    }

    // Helper function to check if nums can be zeroed with the current effects
    private boolean canBeZeroed(int[] nums, int[] effects) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > effects[i]) {
                return false; // If any element is greater than the effect, return false
            }
        }
        return true;
    }
}
